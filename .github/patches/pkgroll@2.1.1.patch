diff --git a/dist/cli.js b/dist/cli.js
index 977c828cfdab926de0ddd6a4056c3b689977927f..58cb4ba03e8ac44ecb1f23b47b11e189537e8a93 100755
--- a/dist/cli.js
+++ b/dist/cli.js
@@ -34,4 +34,4 @@
 `+" ".repeat(e)),new Array(L).fill(0).map((u,e)=>`
 `+"	".repeat(e)),new Array(L).fill(0).map((u,e)=>"\r"+"	".repeat(e)),new Array(L).fill(0).map((u,e)=>`\r
 `+"	".repeat(e));var Du;(function(u){u.DEFAULT={allowTrailingComma:!1}})(Du||(Du={}));function Bt(u,e=[],t=Du.DEFAULT){let D=null,n=[];const r=[];function o(s){Array.isArray(n)?n.push(s):D!==null&&(n[D]=s)}return i(o,"o"),At(u,{onObjectBegin:()=>{const s={};o(s),r.push(n),n=s,D=null},onObjectProperty:s=>{D=s},onObjectEnd:()=>{n=r.pop()},onArrayBegin:()=>{const s=[];o(s),r.push(n),n=s,D=null},onArrayEnd:()=>{n=r.pop()},onLiteralValue:o,onError:(s,a,l)=>{e.push({error:s,offset:a,length:l})}},t),n[0]}i(Bt,"we");function At(u,e,t=Du.DEFAULT){const D=mt(u,!1),n=[];function r(B){return B?()=>B(D.getTokenOffset(),D.getTokenLength(),D.getTokenStartLine(),D.getTokenStartCharacter()):()=>!0}i(r,"s");function o(B){return B?()=>B(D.getTokenOffset(),D.getTokenLength(),D.getTokenStartLine(),D.getTokenStartCharacter(),()=>n.slice()):()=>!0}i(o,"o");function s(B){return B?b=>B(b,D.getTokenOffset(),D.getTokenLength(),D.getTokenStartLine(),D.getTokenStartCharacter()):()=>!0}i(s,"m");function a(B){return B?b=>B(b,D.getTokenOffset(),D.getTokenLength(),D.getTokenStartLine(),D.getTokenStartCharacter(),()=>n.slice()):()=>!0}i(a,"u");const l=o(e.onObjectBegin),C=a(e.onObjectProperty),c=r(e.onObjectEnd),f=o(e.onArrayBegin),E=r(e.onArrayEnd),p=a(e.onLiteralValue),h=s(e.onSeparator),w=r(e.onComment),O=s(e.onError),v=t&&t.disallowComments,F=t&&t.allowTrailingComma;function m(){for(;;){const B=D.scan();switch(D.getTokenError()){case 4:d(14);break;case 5:d(15);break;case 3:d(13);break;case 1:v||d(11);break;case 2:d(12);break;case 6:d(16);break}switch(B){case 12:case 13:v?d(10):w();break;case 16:d(1);break;case 15:case 14:break;default:return B}}}i(m,"g");function d(B,b=[],yu=[]){if(O(B),b.length+yu.length>0){let Z=D.getToken();for(;Z!==17;){if(b.indexOf(Z)!==-1){m();break}else if(yu.indexOf(Z)!==-1)break;Z=m()}}}i(d,"c");function A(B){const b=D.getTokenValue();return B?p(b):(C(b),n.push(b)),m(),!0}i(A,"$");function y(){switch(D.getToken()){case 11:const B=D.getTokenValue();let b=Number(B);isNaN(b)&&(d(2),b=0),p(b);break;case 7:p(null);break;case 8:p(!0);break;case 9:p(!1);break;default:return!1}return m(),!0}i(y,"A");function AD(){return D.getToken()!==10?(d(3,[],[2,5]),!1):(A(!1),D.getToken()===6?(h(":"),m(),tu()||d(4,[],[2,5])):d(5,[],[2,5]),n.pop(),!0)}i(AD,"ce");function bD(){l(),m();let B=!1;for(;D.getToken()!==2&&D.getToken()!==17;){if(D.getToken()===5){if(B||d(4,[],[]),h(","),m(),D.getToken()===2&&F)break}else B&&d(6,[],[]);AD()||d(4,[],[2,5]),B=!0}return c(),D.getToken()!==2?d(7,[2],[]):m(),!0}i(bD,"pe");function yD(){f(),m();let B=!0,b=!1;for(;D.getToken()!==4&&D.getToken()!==17;){if(D.getToken()===5){if(b||d(4,[],[]),h(","),m(),D.getToken()===4&&F)break}else b&&d(6,[],[]);B?(n.push(0),B=!1):n[n.length-1]++,tu()||d(4,[],[4,5]),b=!0}return E(),B||n.pop(),D.getToken()!==4?d(8,[4],[]):m(),!0}i(yD,"me");function tu(){switch(D.getToken()){case 3:return yD();case 1:return bD();case 10:return A(!0);default:return y()}}return i(tu,"S"),m(),D.getToken()===17?t.allowEmptyContent?!0:(d(4,[],[]),!1):tu()?(D.getToken()!==17&&d(9,[],[]),!0):(d(4,[],[]),!1)}i(At,"Te");var rD;(function(u){u[u.None=0]="None",u[u.UnexpectedEndOfComment=1]="UnexpectedEndOfComment",u[u.UnexpectedEndOfString=2]="UnexpectedEndOfString",u[u.UnexpectedEndOfNumber=3]="UnexpectedEndOfNumber",u[u.InvalidUnicode=4]="InvalidUnicode",u[u.InvalidEscapeCharacter=5]="InvalidEscapeCharacter",u[u.InvalidCharacter=6]="InvalidCharacter"})(rD||(rD={}));var oD;(function(u){u[u.OpenBraceToken=1]="OpenBraceToken",u[u.CloseBraceToken=2]="CloseBraceToken",u[u.OpenBracketToken=3]="OpenBracketToken",u[u.CloseBracketToken=4]="CloseBracketToken",u[u.CommaToken=5]="CommaToken",u[u.ColonToken=6]="ColonToken",u[u.NullKeyword=7]="NullKeyword",u[u.TrueKeyword=8]="TrueKeyword",u[u.FalseKeyword=9]="FalseKeyword",u[u.StringLiteral=10]="StringLiteral",u[u.NumericLiteral=11]="NumericLiteral",u[u.LineCommentTrivia=12]="LineCommentTrivia",u[u.BlockCommentTrivia=13]="BlockCommentTrivia",u[u.LineBreakTrivia=14]="LineBreakTrivia",u[u.Trivia=15]="Trivia",u[u.Unknown=16]="Unknown",u[u.EOF=17]="EOF"})(oD||(oD={}));const bt=Bt;var iD;(function(u){u[u.InvalidSymbol=1]="InvalidSymbol",u[u.InvalidNumberFormat=2]="InvalidNumberFormat",u[u.PropertyNameExpected=3]="PropertyNameExpected",u[u.ValueExpected=4]="ValueExpected",u[u.ColonExpected=5]="ColonExpected",u[u.CommaExpected=6]="CommaExpected",u[u.CloseBraceExpected=7]="CloseBraceExpected",u[u.CloseBracketExpected=8]="CloseBracketExpected",u[u.EndOfFileExpected=9]="EndOfFileExpected",u[u.InvalidCommentToken=10]="InvalidCommentToken",u[u.UnexpectedEndOfComment=11]="UnexpectedEndOfComment",u[u.UnexpectedEndOfString=12]="UnexpectedEndOfString",u[u.UnexpectedEndOfNumber=13]="UnexpectedEndOfNumber",u[u.InvalidUnicode=14]="InvalidUnicode",u[u.InvalidEscapeCharacter=15]="InvalidEscapeCharacter",u[u.InvalidCharacter=16]="InvalidCharacter"})(iD||(iD={}));const sD=i((u,e)=>bt(gt(e,u,"utf8")),"te"),yt=Symbol("implicitBaseUrl"),wt=i(()=>{const{findPnpApi:u}=xu;return u&&u(process.cwd())},"Ae"),hu=i((u,e,t,D)=>{const n=`resolveFromPackageJsonPath:${u}:${e}:${t}`;if(D!=null&&D.has(n))return D.get(n);const r=sD(u,D);if(!r)return;let o=e||"tsconfig.json";if(!t&&r.exports)try{const[s]=dt(r.exports,e,["require","types"]);o=s}catch{return!1}else!e&&r.tsconfig&&(o=r.tsconfig);return o=g.join(u,"..",o),D?.set(n,o),o},"G"),mu="package.json",Bu="tsconfig.json",$t=i((u,e,t)=>{let D=u;if(u===".."&&(D=g.join(D,Bu)),u[0]==="."&&(D=g.resolve(e,D)),g.isAbsolute(D)){if(x(t,D)){if(uu(t,D).isFile())return D}else if(!D.endsWith(".json")){const E=`${D}.json`;if(x(t,E))return E}return}const[n,...r]=u.split("/"),o=n[0]==="@"?`${n}/${r.shift()}`:n,s=r.join("/"),a=wt();if(a){const{resolveRequest:E}=a;try{if(o===u){const p=E(g.join(o,mu),e);if(p){const h=hu(p,s,!1,t);if(h&&x(t,h))return h}}else{let p;try{p=E(u,e,{extensions:[".json"]})}catch{p=E(g.join(u,Bu),e)}if(p)return p}}catch{}}const l=tD(g.resolve(e),g.join("node_modules",o),t);if(!l||!uu(t,l).isDirectory())return;const C=g.join(l,mu);if(x(t,C)){const E=hu(C,s,!1,t);if(E===!1)return;if(E&&x(t,E)&&uu(t,E).isFile())return E}const c=g.join(l,s),f=c.endsWith(".json");if(!f){const E=`${c}.json`;if(x(t,E))return E}if(x(t,c)){if(uu(t,c).isDirectory()){const E=g.join(c,mu);if(x(t,E)){const h=hu(E,"",!0,t);if(h&&x(t,h))return h}const p=g.join(c,Bu);if(x(t,p))return p}else if(f)return c}},"Oe"),vt=i((u,e,t,D)=>{const n=$t(u,e,D);if(!n)throw new Error(`File '${u}' not found.`);if(t.has(n))throw new Error(`Circularity detected while resolving configuration: ${n}`);t.add(n);const r=g.dirname(n),o=aD(n,D,t);delete o.references;const{compilerOptions:s}=o;if(s){const a=["baseUrl","outDir"];for(const l of a){const C=s[l];C&&(s[l]=S(g.relative(e,g.join(r,C)))||"./")}}return o.files&&(o.files=o.files.map(a=>S(g.relative(e,g.join(r,a))))),o.include&&(o.include=o.include.map(a=>S(g.relative(e,g.join(r,a))))),o.exclude&&(o.exclude=o.exclude.map(a=>S(g.relative(e,g.join(r,a))))),o},"je"),aD=i((u,e,t=new Set)=>{let D;try{D=sD(u,e)||{}}catch{throw new Error(`Cannot resolve tsconfig at path: ${u}`)}if(typeof D!="object")throw new SyntaxError(`Failed to parse tsconfig at: ${u}`);const n=g.dirname(u);if(D.compilerOptions){const{compilerOptions:r}=D;r.paths&&!r.baseUrl&&(r[yt]=n)}if(D.extends){const r=Array.isArray(D.extends)?D.extends:[D.extends];delete D.extends;for(const o of r.reverse()){const s=vt(o,n,new Set(t),e),a={...s,...D,compilerOptions:{...s.compilerOptions,...D.compilerOptions}};s.watchOptions&&(a.watchOptions={...s.watchOptions,...D.watchOptions}),D=a}}if(D.compilerOptions){const{compilerOptions:r}=D,o=["baseUrl","rootDir"];for(const a of o){const l=r[a];if(l){const C=g.resolve(n,l),c=du(g.relative(n,C));r[a]=c}}const{outDir:s}=r;s&&(Array.isArray(D.exclude)||(D.exclude=[]),D.exclude.includes(s)||D.exclude.push(s),r.outDir=du(s))}else D.compilerOptions={};if(D.files&&(D.files=D.files.map(du)),D.include&&(D.include=D.include.map(S)),D.watchOptions){const{watchOptions:r}=D;r.excludeDirectories&&(r.excludeDirectories=r.excludeDirectories.map(o=>S(g.resolve(n,o))))}return D},"ie"),xt=i((u,e=new Map)=>aD(u,e),"le"),kt=i((u=process.cwd(),e="tsconfig.json",t=new Map)=>{const D=tD(S(u),e,t);if(!D)return null;const n=xt(D,t);return{path:D,config:n}},"$e");g.posix,process.platform;const lD=kt(),Ot=i(u=>{const e=TD.createFilter(/\.([cm]?ts|[jt]sx)$/);return{name:"esbuild-transform",transform:async(t,D)=>{if(!e(D))return null;const n=await vu.transform(t,{...u,loader:"default",sourcefile:D.replace(/\.[cm]ts/,".ts"),tsconfigRaw:lD?.config});return{code:n.code,map:n.map||null}}}},"esbuildTransform"),jt=i(u=>{if(u==="es")return"esm";if(u==="cjs"||u==="iife")return u},"getEsbuildFormat"),Tt=i(u=>({name:"esbuild-minify",renderChunk:async(e,t,D)=>{const n=await vu.transform(e,{...u,format:jt(D.format),minify:!0,keepNames:!0});return{code:n.code,map:n.map||null}}}),"esbuildMinify"),Au=i((u,e)=>u[0]-e[0]||u[1]-e[1]||u[2]-e[2],"compareSemver"),cD=i(({target:u})=>{const e=u.some(t=>{if(t=t.trim(),!t.startsWith("node"))return;const D=t.slice(4).split(".").map(Number),n=[D[0],D[1]??0,D[2]??0];return!(Au(n,[12,20,0])>=0&&Au(n,[13,0,0])<0||Au(n,[14,13,1])>=0)});return{name:"externalize-node-builtins",resolveId:t=>{const D=t.startsWith("node:");if(e&&D&&(t=t.slice(5)),xu.builtinModules.includes(t)||D)return{id:t,external:!0}}}},"externalizeNodeBuiltins"),St=i(u=>({name:"patch-binary",renderChunk:(e,t,D)=>{if(!t.isEntry||!t.facadeModuleId)return;const n=D.entryFileNames,r=`./${g.posix.join(D.dir,n(t))}`;if(u.includes(r)){const o=new ku(e);return o.prepend(`#!/usr/bin/env node
-`),{code:o.toString(),map:D.sourcemap?o.generateMap({hires:!0}):void 0}}},writeBundle:async(e,t)=>{const D=e.entryFileNames,n=Object.values(t).map(async r=>{const o=r;if(o.isEntry&&o.facadeModuleId){const s=`./${g.posix.join(e.dir,D(o))}`;await j.promises.chmod(s,493)}});await Promise.all(n)}}),"patchBinary"),FD=i(()=>{const u=/\.(?:[mc]?js|jsx)$/;return{name:"resolve-typescript-mjs-cjs",resolveId(e,t,D){return u.test(e)&&t?this.resolve(e.replace(/js(x?)$/,"ts$1"),t,D):null}}},"resolveTypescriptMjsCts"),CD=/^#!.*/,Pt=i(()=>({name:"strip-hashbang",transform:u=>{if(!CD.test(u))return null;const e=new ku(u);return e.replace(CD,""),{code:e.toString(),map:e.generateMap({hires:!0})}}}),"stripHashbang"),Nt=["peerDependencies","dependencies","optionalDependencies"],bu="@types/",ED=i((u,e,t=!1)=>{const D=[],{devDependencies:n}=u;for(const r of Nt){const o=u[r];if(!o)continue;const s=Object.keys(o);for(const a of s)if(!(a in e))if(a.startsWith(bu)){if(t){let l=a.slice(bu.length);l.includes("__")&&(l=`@${l.replace("__","/")}`),D.push(l)}}else{if(n&&t){const l=bu+a.replace("@","").replace("/","__");n[l]&&!(l in o)&&console.warn(`Recommendation: "${l}" is externalized because "${a}" is in "${r}". Place "${l}" in "${r}" as well so users don't have missing types.`)}D.push(a)}}return D.flatMap(r=>[r,new RegExp(`^${r}/`)])},"getExternalDependencies"),fD=i(u=>u.split("?")[0],"stripQuery"),pD={type:async u=>{const e=await Promise.resolve().then(function(){return require("./rollup-plugin-dts-BzOer96X.js")});return{input:[],preserveEntrySignatures:"strict",plugins:[cD(u),FD(),e.default({respectExternal:!0,compilerOptions:{composite:!1}})],output:[],external:[]}},app:(u,e,t,D)=>{const n={target:u.target};return{input:[],preserveEntrySignatures:"strict",plugins:[cD(u),FD(),OD({entries:e}),vD({extensions:[".mjs",".js",".ts",".jsx",".tsx",".json"],exportConditions:u.exportCondition}),...Object.keys(t).length>0?[$u({preventAssignment:!0,objectGuards:!0,values:t})]:[],Pt(),xD(),kD(),Ot(n),it(),...u.minify?[Tt(n)]:[],St(D)],output:[],external:[]}}},It=i(async(u,e,t,D,n,r)=>{const o=t.filter(({exportEntry:c})=>c.isExecutable).map(({exportEntry:c})=>c.outputPath),s=Object.create(null),a=Object.fromEntries(D.env.map(({key:c,value:f})=>[`process.env.${c}`,JSON.stringify(f)])),l=ED(r,n),C=ED(r,n,!0);for(const{input:c,srcExtension:f,distExtension:E,exportEntry:p}of t){if(p.type==="types"){let F=s.type;F||(F=await pD.type(D),F.external=C,s.type=F),F.input.includes(c)||F.input.push(c),F.output.push({dir:e,entryFileNames:m=>j.realpathSync.native(fD(m.facadeModuleId)).slice(u.length,-f.length)+E,exports:"auto",format:"esm"});continue}let h=s.app;h||(h=pD.app(D,n,a,o),h.external=l,s.app=h),h.input.includes(c)||h.input.push(c);const w=h.output,O=g.extname(p.outputPath),v=`${p.type}-${O}`;if(!w[v]){const F={dir:e,exports:"auto",format:p.type,chunkFileNames:`[name]-[hash]${O}`,sourcemap:D.sourcemap,plugins:[st(p.type==="module")],entryFileNames:m=>{const A=j.realpathSync.native(fD(m.facadeModuleId)).slice(u.length),[y]=A.split(".");return y+E}};w.push(F),w[v]=F}}return s},"getRollupConfigs");let N=!0;const M=typeof self<"u"?self:typeof window<"u"?window:typeof global<"u"?global:{};let G=0;if(M.process&&M.process.env&&M.process.stdout){const{FORCE_COLOR:u,NODE_DISABLE_COLORS:e,NO_COLOR:t,TERM:D,COLORTERM:n}=M.process.env;e||t||u==="0"?N=!1:u==="1"||u==="2"||u==="3"?N=!0:D==="dumb"?N=!1:"CI"in M.process.env&&["TRAVIS","CIRCLECI","APPVEYOR","GITLAB_CI","GITHUB_ACTIONS","BUILDKITE","DRONE"].some(r=>r in M.process.env)?N=!0:N=process.stdout.isTTY,N&&(process.platform==="win32"||n&&(n==="truecolor"||n==="24bit")?G=3:D&&(D.endsWith("-256color")||D.endsWith("256"))?G=2:G=1)}let dD={enabled:N,supportLevel:G};function _t(u,e,t=1){const D=`\x1B[${u}m`,n=`\x1B[${e}m`,r=new RegExp(`\\x1b\\[${e}m`,"g");return o=>dD.enabled&&dD.supportLevel>=t?D+(""+o).replace(r,D)+n:""+o}i(_t,"kolorist");const Rt=_t(90,39),Lt=i(()=>new Date().toLocaleTimeString(),"currentTime"),eu=i((...u)=>console.log(`[${Rt(Lt())}]`,...u),"log"),Mt=i(async u=>{await cu(u)&&await j.promises.rm(u,{recursive:!0,force:!0})},"cleanDist"),{stringify:gD}=JSON,U=Ye({name:"pkgroll",version:Qe,flags:{src:{type:String,description:"Source directory",default:"./src"},dist:{type:String,description:"Distribution directory",default:"./dist"},minify:{type:Boolean,description:"Minify output",alias:"m",default:!1},target:{type:[String],default:[`node${process.versions.node}`],description:"Environments to support. `target` in tsconfig.json is automatically added. Defaults to the current Node.js version.",alias:"t"},watch:{type:Boolean,description:"Watch mode",alias:"w",default:!1},env:{type:[u=>{const[e,t]=u.split("=");return{key:e,value:t}}],description:"Compile-time environment variables (eg. --env.NODE_ENV=production)"},exportCondition:{type:[String],description:"Export conditions for resolving dependency export and import maps (eg. --export-condition=node)"},sourcemap:{type:u=>{if(u==="")return!0;if(u==="inline")return u;throw new Error(`Invalid sourcemap option ${gD(u)}`)},description:"Sourcemap generation. Provide `inline` option for inline sourcemap (eg. --sourcemap, --sourcemap=inline)"},cleanDist:{type:Boolean,description:"Clean dist before bundling",default:!1}},help:{description:"Minimalistic package bundler",render:(u,e)=>(e.flagOperator=t=>t.name==="env"?".key=":" ",e.render(u))}}),hD=process.cwd(),mD=X(U.flags.src,!0),K=X(U.flags.dist,!0),BD=lD?.config.compilerOptions?.target;BD&&U.flags.target.push(BD),(async()=>{const u=await Xe(hD);let e=Dt(u);if(e=e.filter(n=>{const r=n.outputPath.startsWith(K);return r||console.warn(`Ignoring entry outside of ${K} directory: package.json#${n.from}=${gD(n.outputPath)}`),r}),e.length===0)throw new Error("No export entries found in package.json");const t=await Promise.all(e.map(async n=>({...await ot(n,mD,K),exportEntry:n}))),D=await It(X(j.realpathSync.native(mD),!0),K,t,U.flags,et(u,hD),u);U.flags.cleanDist&&await Mt(K),U.flags.watch?(eu("Watch initialized"),Object.values(D).map(async n=>{wu.watch(n).on("event",async o=>{o.code==="BUNDLE_START"&&eu("Building",...Array.isArray(o.input)?o.input:[o.input]),o.code==="BUNDLE_END"&&(await Promise.all(n.output.map(s=>o.result.write(s))),eu("Built",...Array.isArray(o.input)?o.input:[o.input])),o.code==="ERROR"&&eu("Error:",o.error.message)})})):await Promise.all(Object.values(D).map(async n=>{const r=await wu.rollup(n);return Promise.all(n.output.map(o=>r.write(o)))}))})().catch(u=>{console.error(u),process.exit(1)});
+`),{code:o.toString(),map:D.sourcemap?o.generateMap({hires:!0}):void 0}}},writeBundle:async(e,t)=>{const D=e.entryFileNames,n=Object.values(t).map(async r=>{const o=r;if(o.isEntry&&o.facadeModuleId){const s=`./${g.posix.join(e.dir,D(o))}`;await j.promises.chmod(s,493)}});await Promise.all(n)}}),"patchBinary"),FD=i(()=>{const u=/\.(?:[mc]?js|jsx)$/;return{name:"resolve-typescript-mjs-cjs",resolveId(e,t,D){return u.test(e)&&t?this.resolve(e.replace(/js(x?)$/,"ts$1"),t,D):null}}},"resolveTypescriptMjsCts"),CD=/^#!.*/,Pt=i(()=>({name:"strip-hashbang",transform:u=>{if(!CD.test(u))return null;const e=new ku(u);return e.replace(CD,""),{code:e.toString(),map:e.generateMap({hires:!0})}}}),"stripHashbang"),Nt=["peerDependencies","dependencies","optionalDependencies"],bu="@types/",ED=i((u,e,t=!1)=>{const D=[],{devDependencies:n}=u;for(const r of Nt){const o=u[r];if(!o)continue;const s=Object.keys(o);for(const a of s)if(!(a in e))if(a.startsWith(bu)){if(t){let l=a.slice(bu.length);l.includes("__")&&(l=`@${l.replace("__","/")}`),D.push(l)}}else{if(n&&t){const l=bu+a.replace("@","").replace("/","__");n[l]&&!(l in o)&&console.warn(`Recommendation: "${l}" is externalized because "${a}" is in "${r}". Place "${l}" in "${r}" as well so users don't have missing types.`)}D.push(a)}}return D.flatMap(r=>[r,new RegExp(`^${r}/`)])},"getExternalDependencies"),fD=i(u=>u.split("?")[0],"stripQuery"),pD={type:async u=>{const e=await Promise.resolve().then(function(){return require("./rollup-plugin-dts-BzOer96X.js")});return{input:[],preserveEntrySignatures:"strict",plugins:[cD(u),FD(),e.default({respectExternal:!0,compilerOptions:{composite:!1,preserveSymlinks:!1}})],output:[],external:[]}},app:(u,e,t,D)=>{const n={target:u.target};return{input:[],preserveEntrySignatures:"strict",plugins:[cD(u),FD(),OD({entries:e}),vD({extensions:[".mjs",".js",".ts",".jsx",".tsx",".json"],exportConditions:u.exportCondition}),...Object.keys(t).length>0?[$u({preventAssignment:!0,objectGuards:!0,values:t})]:[],Pt(),xD(),kD(),Ot(n),it(),...u.minify?[Tt(n)]:[],St(D)],output:[],external:[]}}},It=i(async(u,e,t,D,n,r)=>{const o=t.filter(({exportEntry:c})=>c.isExecutable).map(({exportEntry:c})=>c.outputPath),s=Object.create(null),a=Object.fromEntries(D.env.map(({key:c,value:f})=>[`process.env.${c}`,JSON.stringify(f)])),l=ED(r,n),C=ED(r,n,!0);for(const{input:c,srcExtension:f,distExtension:E,exportEntry:p}of t){if(p.type==="types"){let F=s.type;F||(F=await pD.type(D),F.external=C,s.type=F),F.input.includes(c)||F.input.push(c),F.output.push({dir:e,entryFileNames:m=>j.realpathSync.native(fD(m.facadeModuleId)).slice(u.length,-f.length)+E,exports:"auto",format:"esm"});continue}let h=s.app;h||(h=pD.app(D,n,a,o),h.external=l,s.app=h),h.input.includes(c)||h.input.push(c);const w=h.output,O=g.extname(p.outputPath),v=`${p.type}-${O}`;if(!w[v]){const F={dir:e,exports:"auto",format:p.type,chunkFileNames:`[name]-[hash]${O}`,sourcemap:D.sourcemap,plugins:[st(p.type==="module")],entryFileNames:m=>{const A=j.realpathSync.native(fD(m.facadeModuleId)).slice(u.length),[y]=A.split(".");return y+E}};w.push(F),w[v]=F}}return s},"getRollupConfigs");let N=!0;const M=typeof self<"u"?self:typeof window<"u"?window:typeof global<"u"?global:{};let G=0;if(M.process&&M.process.env&&M.process.stdout){const{FORCE_COLOR:u,NODE_DISABLE_COLORS:e,NO_COLOR:t,TERM:D,COLORTERM:n}=M.process.env;e||t||u==="0"?N=!1:u==="1"||u==="2"||u==="3"?N=!0:D==="dumb"?N=!1:"CI"in M.process.env&&["TRAVIS","CIRCLECI","APPVEYOR","GITLAB_CI","GITHUB_ACTIONS","BUILDKITE","DRONE"].some(r=>r in M.process.env)?N=!0:N=process.stdout.isTTY,N&&(process.platform==="win32"||n&&(n==="truecolor"||n==="24bit")?G=3:D&&(D.endsWith("-256color")||D.endsWith("256"))?G=2:G=1)}let dD={enabled:N,supportLevel:G};function _t(u,e,t=1){const D=`\x1B[${u}m`,n=`\x1B[${e}m`,r=new RegExp(`\\x1b\\[${e}m`,"g");return o=>dD.enabled&&dD.supportLevel>=t?D+(""+o).replace(r,D)+n:""+o}i(_t,"kolorist");const Rt=_t(90,39),Lt=i(()=>new Date().toLocaleTimeString(),"currentTime"),eu=i((...u)=>console.log(`[${Rt(Lt())}]`,...u),"log"),Mt=i(async u=>{await cu(u)&&await j.promises.rm(u,{recursive:!0,force:!0})},"cleanDist"),{stringify:gD}=JSON,U=Ye({name:"pkgroll",version:Qe,flags:{src:{type:String,description:"Source directory",default:"./src"},dist:{type:String,description:"Distribution directory",default:"./dist"},minify:{type:Boolean,description:"Minify output",alias:"m",default:!1},target:{type:[String],default:[`node${process.versions.node}`],description:"Environments to support. `target` in tsconfig.json is automatically added. Defaults to the current Node.js version.",alias:"t"},watch:{type:Boolean,description:"Watch mode",alias:"w",default:!1},env:{type:[u=>{const[e,t]=u.split("=");return{key:e,value:t}}],description:"Compile-time environment variables (eg. --env.NODE_ENV=production)"},exportCondition:{type:[String],description:"Export conditions for resolving dependency export and import maps (eg. --export-condition=node)"},sourcemap:{type:u=>{if(u==="")return!0;if(u==="inline")return u;throw new Error(`Invalid sourcemap option ${gD(u)}`)},description:"Sourcemap generation. Provide `inline` option for inline sourcemap (eg. --sourcemap, --sourcemap=inline)"},cleanDist:{type:Boolean,description:"Clean dist before bundling",default:!1}},help:{description:"Minimalistic package bundler",render:(u,e)=>(e.flagOperator=t=>t.name==="env"?".key=":" ",e.render(u))}}),hD=process.cwd(),mD=X(U.flags.src,!0),K=X(U.flags.dist,!0),BD=lD?.config.compilerOptions?.target;BD&&U.flags.target.push(BD),(async()=>{const u=await Xe(hD);let e=Dt(u);if(e=e.filter(n=>{const r=n.outputPath.startsWith(K);return r||console.warn(`Ignoring entry outside of ${K} directory: package.json#${n.from}=${gD(n.outputPath)}`),r}),e.length===0)throw new Error("No export entries found in package.json");const t=await Promise.all(e.map(async n=>({...await ot(n,mD,K),exportEntry:n}))),D=await It(X(j.realpathSync.native(mD),!0),K,t,U.flags,et(u,hD),u);U.flags.cleanDist&&await Mt(K),U.flags.watch?(eu("Watch initialized"),Object.values(D).map(async n=>{wu.watch(n).on("event",async o=>{o.code==="BUNDLE_START"&&eu("Building",...Array.isArray(o.input)?o.input:[o.input]),o.code==="BUNDLE_END"&&(await Promise.all(n.output.map(s=>o.result.write(s))),eu("Built",...Array.isArray(o.input)?o.input:[o.input])),o.code==="ERROR"&&eu("Error:",o.error.message)})})):await Promise.all(Object.values(D).map(async n=>{const r=await wu.rollup(n);return Promise.all(n.output.map(o=>r.write(o)))}))})().catch(u=>{console.error(u),process.exit(1)});
